#ifndef _GPUTILS_HPP
#define _GPUTILS_HPP

// By default, pybind11 files are not included!
//
// #include "gputils/dlpack.h"                // from https://github.com/dmlc/dlpack
// #include "gputils/pybind11.hpp"            // externally visible Array<> converters
// #include "gputils/pybind11_utils.gpp"      // utility functions, unlikely to be useful from outside gputils

// Array class
#include "gputils/Array.hpp"

// Barrier: synchronization point between N threads
#include "gputils/Barrier.hpp"

// CudaStreamPool: run multiple streams with dynamic load-balancing, intended for timing.
#include "gputils/CudaStreamPool.hpp"

// CpuThreadPool: run multiple CPU threads with dynamic load-balancing, intended for timing.
#include "gputils/CpuThreadPool.hpp"

// ThreadSafeRingBuffer<T>: pass data between producer/consumer threads.
#include "gputils/ThreadSafeRingBuffer.hpp"

// is_complex_v<T>, decomplexify_type<T>::type
#include "gputils/complex_type_traits.hpp"

// constexpr_is_pow2(), constexpr_ilog2()
#include "gputils/constexpr_functions.hpp"

// CUDA_CALL(), CUDA_PEEK(), CudaStreamWrapper
#include "gputils/cuda_utils.hpp"

// mma_* wrappers for mma.* PTX instructions (autogenerated by generate_device_mma_hpp.py)
#include "gputils/device_mma.hpp"

// af_alloc(), af_copy(), af_clone()
#include "gputils/mem_utils.hpp"

// Drop-in-replacement for 1d and 2d GPU-to-GPU cudaMemcpyAsync(), but uses SMs instead of a copy engine.
#include "gputils/memcpy_kernels.hpp"

// rand_int(), rand_uniform(), randomize()
#include "gputils/rand_utils.hpp"

// to_str(), from_str(), tuple_str(), type_name()
#include "gputils/string_utils.hpp"

// assert_arrays_equal()
#include "gputils/test_utils.hpp"

// get_time(), time_diff(), time_since()
#include "gputils/time_utils.hpp"

// xassert(), xassert_msg(), xassert_eq(), etc.
#include "gputils/xassert.hpp"

#endif // _GPUTILS_HPP
